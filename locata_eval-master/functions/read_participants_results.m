function [ out , meta_data ] = read_participants_results( data_dir, eval_dir, valid_submission_ids, opts )

% Reads ground-truth data for a given LOCATA dataset
%
% INPUT:
% data_dir: folder with the participants' results
% eval_dir: folder with ground-truth evaluation data
% opts:     struct generated by init()
%
% OUTPUT:
% out:       16 x 4 x 26 x 6 cell array with participants' results
%            out{ p_ID, array_idx, rec_idx, task_idx }
%            fields are empty, e.g., if only recording 6 to 10 are
%            processed or only one array is used
% meta_data: 16 element cell array meta_data{ID}.p_data
%            with all participants data (ID=1:16)
%            generated by participants_data( ID )
%
% author: Heiner Loellmann (LMS, FAU), 2020 
%
% Notice: This programm is part of the LOCATA evaluation release. 
%         Please report problems and bugs to info@locata-challenge.org.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF OPEN DATA
% COMMONS ATTRIBUTION LICENSE (ODC-BY) v1.0, WHICH CAN BE FOUND AT
% http://opendatacommons.org/licenses/by/1.0/.
% THE WORK IS PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE
% OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW
% IS PROHIBITED.
%
% BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE
% TO BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY
% BE CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS
% CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND
% CONDITIONS.
%
% -------------------------------------------------------------------------
%
% Representations, Warranties and Disclaimer
%
% UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR
% OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY
% KIND CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE,
% INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY,
% FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF
% LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS,
% WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE
% EXCLUSION OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.
%
% Limitation on Liability.
%
% EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN NO EVENT WILL
% LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR ANY SPECIAL,
% INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF
% THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED
% OF THE POSSIBILITY OF SUCH DAMAGES.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

eps = 10e-12; % tolerance for checking time stampls

for p_no = valid_submission_ids % loop over all submission IDs (= no. of algorithms)
    
    % load setting of each participant
    p_data = participants_data( p_no );
    meta_data{p_no} = p_data;  % meta data of each submission
    
    tasks = p_data.tasks;
    alg_name = p_data.alg;
    array_names = p_data.arrays;
    array_id    = p_data.array_id;
    
    fprintf('\n Processing results of %s, ID %d: \n\n', p_data.name, p_no );
    
    for task_idx = 1:length(tasks)
        
        this_task = tasks{task_idx};
        recordings = p_data.recordings{task_idx};
        
        for rec_idx = 1:length(recordings)
            
            this_recording = recordings(rec_idx);
            
            for i = 1:length( array_names)
                
                arr_no = array_id( i );       % array number   (benchmark2, dicit, dummy, eigenmike -> 1,2,3,4)
                this_array = array_names{ i }; % array name
                
                flag_valid = 1; % indicates whether the checks are successfull
                fprintf('Processing task %d, recording %d, %s...\n', this_task, this_recording, this_array);
                
                array_dir = [ data_dir, p_data.s_folder, filesep , 'task', num2str(this_task), filesep, 'recording', num2str(this_recording) , filesep , this_array, filesep, alg_name ];
                if ~exist( array_dir, 'dir') % can only appear for test cases
                    error(['Directory does not exist: ', array_dir]) 
                end
                txt_files = dir( [array_dir, filesep, 'source_*.txt'] );
                NoS = length( ~cellfun(@isempty, regexp({txt_files.name}, 'source')) );
                
                if NoS == 0
                    error('No valid txt-file found')
                    flag_valid = 0;
                else
                    fprintf('%d Source(s) ...\n', NoS )
                end
                
                if (this_task==1 || this_task==3 || this_task==5) && NoS > 1
                    fprintf('Multiple sources for single source sceneario. \n') 
                    % warning('Multiple sources for single source sceneario') 
                    % No warning since no mistake of the participants
                end
                
                Estimates = [];  % clear previous values
                source_idx = 0;
                for source_cnt = 1:NoS
                    source_idx = source_idx+1; % second counter since files without source activity are skipped
                    
                    % Load participant data from source_?.txt files
                    f_name = [ array_dir, filesep, 'source_',num2str(source_cnt),'.txt' ];
                    p_table = readtable( f_name );
                    p_array = table2array( p_table);
                    
                    % Removal of (spurious) source IDs
                    if strcmp('P_13',p_data.name) || strcmp('P_14',p_data.name)
                        
                        p_array = p_array(:,1:end-1);
                        
                    elseif strcmp('P_3',p_data.name)
                        
                        p_array = p_array(:, [1:7,9:end] );
                        
                    end
                    
                    N_tab = length( p_array(1,:));
                    p_time = p_array(:,1:6);
                    p_timestamps = p_array(:,7);
                    azimuth = p_array(:,8);
                    if max(abs(azimuth))>2*pi
                        warning('Azimuth value beyond 2pi detected')
                    end
                    
                    if N_tab > 8
                        elevation = p_array(:,9);
                        if max(abs(elevation))>2*pi
                            warning('Elevation value beyond 2pi detected')
                        end
                    else
                        elevation = []; % no elevation provided
                    end
                    
                    % Check the time stamps with those of the eval database
                    %
                    f_name_eval = [ eval_dir, filesep, 'task', num2str(this_task), ...
                        filesep, 'recording', num2str(this_recording), filesep, this_array, filesep, 'required_time.txt'];  % file of eval database
                    e_times = readtable(f_name_eval);
                    e_array = table2array( e_times );
                    e_timestamps = elapsed_time( e_array.').';
                    e_time = e_array(:,1:6);
                    
                    if length(p_timestamps)~=length(e_timestamps)
                        
                        warning('Unequal length for timestamps')
                        diff = length(e_timestamps) - length(p_timestamps)
                        flag_valid = 0;  % incorrect txt file, results should not be saved
                        
                    else
                        
                        delta_timestamps = max(abs(p_timestamps-e_timestamps));
                        if delta_timestamps > eps
                            warning('Timestamps differ')
                            delta_timestamps
                            flag_valid = 0;  % incorrect txt file, results should not be saved
                        end
                        
                        delta_time = abs( sum(sum( e_time - p_time )) );
                        if delta_time > eps
                            warning('Time data differs!')
                            delta_time
                        end
                        
                    end
                    
                    % Deterimine voice activity based on NaN values
                    %
                    idx_vad = find( ~isnan( azimuth ) );  % index for regular entries
                    if length(idx_vad) == length(p_timestamps)
                        
                        fprintf('No VAD performed \n')
                        
                    elseif  isempty( idx_vad )
                        
                        warning(['All azimuth estimates for source ', num2str(source_cnt), ' are NaN values. Source excluded from results.'])
                        source_idx = source_idx-1;
                        continue
                    end
                    
                    % Initialize so all fields exist but are empty if not used / applicable
                    %
                    for f_idx = 1:length( opts.valid_results )
                        Estimates.source( source_idx ).(opts.valid_results{f_idx}) = [];
                    end
                    Estimates.source( source_idx ).time = p_array( idx_vad, 1:6 );
                    Estimates.source( source_idx ).timestamps = p_timestamps( idx_vad );
                    Estimates.source( source_idx ).azimuth = azimuth( idx_vad );
                    if N_tab == 9
                        Estimates.source( source_idx ).elevation = elevation( idx_vad );
                    end
                    
                    if N_tab == 12 % applies only for one candidate (P_3)
                        Estimates.source( source_idx ).x = p_array( idx_vad, 10 );
                        Estimates.source( source_idx ).y = p_array( idx_vad, 11 );
                        Estimates.source( source_idx ).z = p_array( idx_vad, 12 );
                    end
                    
                    if  ~(N_tab==12 || N_tab==9 || N_tab==8)
                        warning('Incorrect number of columns')
                        flag_valid = 0;
                    end
                    
                    if isempty( Estimates.source(source_idx).azimuth )
                        error('Empty value for Estimates')
                    end
                    
                end % eof source loop
                
                if flag_valid
                    % store in output variable
                    out{ p_no, arr_no, this_recording, this_task } = Estimates;
                else
                    % warning('Incorrect results!')
                    error('Incorrect results!')
                end
                
            end % eof array loop
            
        end % eof recording loop
        
    end % eof task loop
    
end % eof participant loop